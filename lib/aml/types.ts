/**
 * AML (Adaptive Markup Language) Type Definitions
 *
 * AML is the script format that drives the APEX Player.
 * These structures are generated by the LLM and interpreted by the renderer.
 */

// ============================================================================
// Document Structure
// ============================================================================

export interface AMLDocument {
    version: string;
    sessionId: string;
    sequences: AMLSequence[];
    metadata?: {
        topic: string;
        generatedAt: number;
        sourceUploadIds?: string[];
    };
}

export interface AMLSequence {
    id: string;
    title?: string;
    duration?: number; // Total duration in seconds (optional, can be calculated)
    actions: AMLAction[];
    checkpoint?: AMLCheckpoint;
}

// ============================================================================
// Actions
// ============================================================================

export interface AMLAction {
    /** Timestamp - number (seconds) or relative string like "+2s" */
    at: number | string;
    type: 'instructor' | 'board' | 'animate' | 'audio';
    content: InstructorAction | BoardAction | AnimateAction | AudioAction;
}

// ----------------------------------------------------------------------------
// Instructor Actions (Avatar behavior)
// ----------------------------------------------------------------------------

export interface InstructorAction {
    /** Avatar display mode */
    mode: 'avatar-simple' | 'abstract';
    /** Emotional tone affecting visual indicators */
    emotion?: 'neutral' | 'friendly' | 'excited' | 'thoughtful' | 'encouraging';
    /** Text to be spoken via TTS */
    speak: string;
    /** Visual gesture/animation to play */
    gesture?: 'wave' | 'point' | 'nod' | 'thinking' | 'celebrate';
    /** Optional: highlight a specific board element while speaking */
    highlightElement?: string;
}

// ----------------------------------------------------------------------------
// Board Actions (Whiteboard content)
// ----------------------------------------------------------------------------

export interface BoardAction {
    /** Which zone of the whiteboard to target */
    zone?: 'left' | 'center' | 'right' | 'full';
    /** Clear previous content before adding new */
    clear?: boolean;
    /** Elements to add/update on the board */
    elements: BoardElement[];
}

export interface BoardElement {
    id: string;
    type: 'text' | 'shape' | 'equation' | 'diagram' | 'image' | 'code';
    position: Position;
    style?: StyleProperties;
    content: TextContent | ShapeContent | EquationContent | DiagramContent | ImageContent | CodeContent;
    /** Animation for element entrance */
    animation?: ElementAnimation;
}

export interface Position {
    x: number;
    y: number;
    width?: number;
    height?: number;
    rotation?: number;
}

export interface StyleProperties {
    fill?: string;
    stroke?: string;
    strokeWidth?: number;
    opacity?: number;
    fontSize?: number;
    fontFamily?: string;
    fontWeight?: 'normal' | 'bold';
    textAlign?: 'left' | 'center' | 'right';
}

// Element content types
export interface TextContent {
    text: string;
    /** For multi-line text */
    lines?: string[];
}

export interface ShapeContent {
    shape: 'rectangle' | 'circle' | 'ellipse' | 'line' | 'arrow' | 'polygon';
    /** For polygons and complex shapes */
    points?: Array<{ x: number; y: number }>;
}

export interface EquationContent {
    /** LaTeX string to render */
    latex: string;
}

export interface DiagramContent {
    /** Diagram type for specialized rendering */
    diagramType: 'flowchart' | 'tree' | 'graph' | 'custom';
    /** Diagram nodes */
    nodes: Array<{
        id: string;
        label: string;
        position: Position;
        style?: StyleProperties;
    }>;
    /** Connections between nodes */
    edges: Array<{
        from: string;
        to: string;
        label?: string;
        style?: StyleProperties;
    }>;
}

export interface ImageContent {
    /** URL or base64 data */
    src: string;
    alt?: string;
}

export interface CodeContent {
    code: string;
    language: string;
    /** Lines to highlight */
    highlightLines?: number[];
}

export interface ElementAnimation {
    type: 'fadeIn' | 'slideIn' | 'draw' | 'typewriter' | 'pop' | 'none';
    duration?: number; // milliseconds
    delay?: number; // milliseconds
    direction?: 'left' | 'right' | 'top' | 'bottom';
}

// ----------------------------------------------------------------------------
// Animate Actions (Transitions and effects)
// ----------------------------------------------------------------------------

export interface AnimateAction {
    /** Target element ID or 'all' for global effects */
    target: string | 'all';
    animation: {
        type: 'move' | 'scale' | 'rotate' | 'highlight' | 'fade' | 'shake';
        to?: Partial<Position>;
        from?: Partial<Position>;
        duration: number;
        easing?: 'linear' | 'easeIn' | 'easeOut' | 'easeInOut' | 'bounce';
    };
}

// ----------------------------------------------------------------------------
// Audio Actions (Sound effects, music)
// ----------------------------------------------------------------------------

export interface AudioAction {
    type: 'sfx' | 'ambient';
    /** Predefined sound effect name or URL */
    sound: string;
    volume?: number; // 0-1
    loop?: boolean;
}

// ============================================================================
// Checkpoints (Interactive moments)
// ============================================================================

export interface AMLCheckpoint {
    id: string;
    type: 'comprehension' | 'question' | 'practice' | 'reflection';
    /** The question or prompt to show */
    prompt: string;
    /** Whether to accept free-form input */
    acceptInput: boolean;
    /** For multiple choice questions */
    options?: CheckpointOption[];
    /** Correct answer for local validation */
    correctAnswer?: string | string[];
    /** Hints to show after wrong attempts */
    hints?: string[];
    /** XP reward for correct answer */
    xpReward?: number;
    /** Whether to use LLM for validation (for complex/essay answers) */
    requiresLLMValidation?: boolean;
}

export interface CheckpointOption {
    id: string;
    text: string;
    isCorrect?: boolean;
}

// ============================================================================
// Utility Types
// ============================================================================

/** Parse relative time strings like "+2s" to absolute seconds */
export function parseTimestamp(at: number | string, baseTime: number = 0): number {
    if (typeof at === 'number') return at;

    const match = at.match(/^([+-])?(\d+(?:\.\d+)?)(s|ms)?$/);
    if (!match) return baseTime;

    const sign = match[1] === '-' ? -1 : 1;
    const value = parseFloat(match[2]);
    const unit = match[3] || 's';

    const seconds = unit === 'ms' ? value / 1000 : value;
    return baseTime + (sign * seconds);
}

/** Calculate total duration of a sequence based on actions */
export function calculateSequenceDuration(sequence: AMLSequence): number {
    if (sequence.duration) return sequence.duration;

    let maxTime = 0;
    for (const action of sequence.actions) {
        const time = parseTimestamp(action.at);
        // Estimate action duration based on type
        let actionDuration = 0;
        if (action.type === 'instructor') {
            const instructor = action.content as InstructorAction;
            // Rough estimate: 150 words per minute
            const wordCount = instructor.speak.split(/\s+/).length;
            actionDuration = (wordCount / 150) * 60;
        }
        maxTime = Math.max(maxTime, time + actionDuration);
    }

    return maxTime;
}

/** Validate AML document structure */
export function validateAMLDocument(doc: unknown): doc is AMLDocument {
    if (!doc || typeof doc !== 'object') return false;
    const d = doc as AMLDocument;

    if (typeof d.version !== 'string') return false;
    if (typeof d.sessionId !== 'string') return false;
    if (!Array.isArray(d.sequences)) return false;

    for (const seq of d.sequences) {
        if (!validateAMLSequence(seq)) return false;
    }

    return true;
}

export function validateAMLSequence(seq: unknown): seq is AMLSequence {
    if (!seq || typeof seq !== 'object') return false;
    const s = seq as AMLSequence;

    if (typeof s.id !== 'string') return false;
    if (!Array.isArray(s.actions)) return false;

    return true;
}

// ============================================================================
// Session History Compression
// ============================================================================

export interface CompressedSequence {
    id: string;
    title?: string;
    summary: string;
    duration: number;
    checkpointPassed: boolean;
    timestamp: number;
}

/** Compress a sequence for storage (keeps essential info, drops full actions) */
export function compressSequence(sequence: AMLSequence, passed: boolean): CompressedSequence {
    // Extract key topics from instructor speak actions
    const speakTexts = sequence.actions
        .filter(a => a.type === 'instructor')
        .map(a => (a.content as InstructorAction).speak)
        .join(' ');

    // Create a brief summary (first 100 chars of combined speech)
    const summary = speakTexts.slice(0, 100) + (speakTexts.length > 100 ? '...' : '');

    return {
        id: sequence.id,
        title: sequence.title,
        summary,
        duration: calculateSequenceDuration(sequence),
        checkpointPassed: passed,
        timestamp: Date.now(),
    };
}
